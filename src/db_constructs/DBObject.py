from typing import List

from src.db_constructs.DBAttribute import DBAttribute
from src.db_constructs.DBPrimitiveObject import DBPrimitiveObject
from src.db_constructs.DBRelation import DBRelation
from src.utility.GenerateDataForType import generate_data_for_type


class DBObject:
    def __init__(self, name, attributes=None, relations=None, count_min=1, count_max="*"):
        self.name = name
        self.attributes: List[DBAttribute] = attributes or []
        self.relations: List[DBRelation] = relations or []  # relations pointing away from this object
        self.scope_count_min = count_min
        self.scope_count_max = count_max
        self.dependency_order = -1

    def add_attribute(self, attribute):
        self.attributes.append(attribute)

    def add_relation(self, relation):
        self.relations.append(relation)

    def to_x_core(self):
        relation_strings = "\n".join([relation.to_x_core() for relation in self.relations])
        if relation_strings:
            return f"class {self.name} {{\n{relation_strings}\n}}"
        else:
            return f"""class {self.name} {{}}"""

    def csvs_to_primitive_objects(self, csv_folder_path, primitive_objects):
        """
        Stores generated DBPrimitives in the given db_primitives list
        """
        primitive_objects.update({self.name: []})
        new_primitives_list = primitive_objects.get(self.name)

        # Generate primitives without relations
        with open(f"./{csv_folder_path}/{self.name}.csv", "r") as file:
            lines = file.readlines()[1:]  # remove header line
            main_csv = [line.split(",")[0] for line in lines if not line.startswith(":")]  # remove weird ::X lines

        for i, primitive_name in enumerate(main_csv):
            db_primitive = DBPrimitiveObject(self.name, primitive_name)

            for attribute in self.attributes:
                generated_value = generate_data_for_type(attribute.db_type, i)
                if generated_value is None and not attribute.nullable:
                    raise Exception(f"Data type not supported: {attribute.db_type}")
                else:
                    db_primitive.update_attribute({attribute.name: generated_value})

            new_primitives_list.append(db_primitive)

        # Fill in the relations of created primitives
        for relation in self.relations:
            if relation.target_attribute.extra == "":  # if extra is empty then the field in not autogenerated
                with open(f"./{csv_folder_path}/{self.name}_{relation.origin_name}.csv", "r") as file:
                    relation_csv = file.readlines()[1:]  # remove header line
                for line in relation_csv:
                    split = line.split(",")
                    origin_name = split[0]
                    target_name = split[1]
                    origin_primitive = [p for p in new_primitives_list if p.name == origin_name][0]
                    target_primitives_list = primitive_objects.get(relation.target_table)
                    target_primitive = [p for p in target_primitives_list if p.name == target_name][0]
                    origin_primitive.update_attribute({
                        relation.origin_name: target_primitive.get_attribute(relation.target_name)
                    })
            else:
                # TODO deal with autogenerated fields
                print("TODO deal with autogenerated fields")
